(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('core-js/modules/es.symbol.js'), require('core-js/modules/es.array.filter.js'), require('core-js/modules/es.array.for-each.js'), require('core-js/modules/es.object.define-properties.js'), require('core-js/modules/es.object.define-property.js'), require('core-js/modules/es.object.get-own-property-descriptor.js'), require('core-js/modules/es.object.get-own-property-descriptors.js'), require('core-js/modules/es.object.keys.js'), require('core-js/modules/es.reflect.construct.js'), require('core-js/modules/web.dom-collections.for-each.js'), require('@babel/runtime/helpers/readOnlyError'), require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/inherits'), require('@babel/runtime/helpers/defineProperty'), require('core-js/modules/es.array.iterator.js'), require('core-js/modules/es.array.map.js'), require('core-js/modules/es.date.to-string.js'), require('core-js/modules/es.object.to-string.js'), require('core-js/modules/es.promise.js'), require('core-js/modules/es.regexp.to-string.js'), require('core-js/modules/es.string.iterator.js'), require('core-js/modules/web.dom-collections.iterator.js'), require('react'), require('ramda'), require('@cubejs-client/core'), require('@babel/runtime/helpers/extends'), require('@babel/runtime/helpers/objectWithoutProperties'), require('@babel/runtime/helpers/toConsumableArray'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/regenerator'), require('core-js/modules/es.array.concat.js'), require('core-js/modules/es.array.find.js'), require('core-js/modules/es.array.includes.js'), require('core-js/modules/es.array.is-array.js'), require('core-js/modules/es.array.reduce.js'), require('core-js/modules/es.array.sort.js'), require('core-js/modules/es.array.splice.js'), require('core-js/modules/es.function.name.js'), require('core-js/modules/es.object.from-entries.js'), require('core-js/modules/es.regexp.exec.js'), require('core-js/modules/es.string.replace.js'), require('@babel/runtime/helpers/typeof'), require('core-js/modules/es.object.entries.js')) :
  typeof define === 'function' && define.amd ? define(['exports', 'core-js/modules/es.symbol.js', 'core-js/modules/es.array.filter.js', 'core-js/modules/es.array.for-each.js', 'core-js/modules/es.object.define-properties.js', 'core-js/modules/es.object.define-property.js', 'core-js/modules/es.object.get-own-property-descriptor.js', 'core-js/modules/es.object.get-own-property-descriptors.js', 'core-js/modules/es.object.keys.js', 'core-js/modules/es.reflect.construct.js', 'core-js/modules/web.dom-collections.for-each.js', '@babel/runtime/helpers/readOnlyError', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/inherits', '@babel/runtime/helpers/defineProperty', 'core-js/modules/es.array.iterator.js', 'core-js/modules/es.array.map.js', 'core-js/modules/es.date.to-string.js', 'core-js/modules/es.object.to-string.js', 'core-js/modules/es.promise.js', 'core-js/modules/es.regexp.to-string.js', 'core-js/modules/es.string.iterator.js', 'core-js/modules/web.dom-collections.iterator.js', 'react', 'ramda', '@cubejs-client/core', '@babel/runtime/helpers/extends', '@babel/runtime/helpers/objectWithoutProperties', '@babel/runtime/helpers/toConsumableArray', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/regenerator', 'core-js/modules/es.array.concat.js', 'core-js/modules/es.array.find.js', 'core-js/modules/es.array.includes.js', 'core-js/modules/es.array.is-array.js', 'core-js/modules/es.array.reduce.js', 'core-js/modules/es.array.sort.js', 'core-js/modules/es.array.splice.js', 'core-js/modules/es.function.name.js', 'core-js/modules/es.object.from-entries.js', 'core-js/modules/es.regexp.exec.js', 'core-js/modules/es.string.replace.js', '@babel/runtime/helpers/typeof', 'core-js/modules/es.object.entries.js'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.cubejsReact = {}, null, null, null, null, null, null, null, null, null, null, null, global._slicedToArray, global._classCallCheck, global._createClass, global._possibleConstructorReturn, global._getPrototypeOf, global._inherits, global._defineProperty, null, null, null, null, null, null, null, null, global.React, global.ramda, global.core, global._extends, global._objectWithoutProperties, global._toConsumableArray, global._asyncToGenerator, global._regeneratorRuntime, null, null, null, null, null, null, null, null, null, null, null, global._typeof));
}(this, (function (exports, es_symbol_js, es_array_filter_js, es_array_forEach_js, es_object_defineProperties_js, es_object_defineProperty_js, es_object_getOwnPropertyDescriptor_js, es_object_getOwnPropertyDescriptors_js, es_object_keys_js, es_reflect_construct_js, web_domCollections_forEach_js, readOnlyError, _slicedToArray, _classCallCheck, _createClass, _possibleConstructorReturn, _getPrototypeOf, _inherits, _defineProperty, es_array_iterator_js, es_array_map_js, es_date_toString_js, es_object_toString_js, es_promise_js, es_regexp_toString_js, es_string_iterator_js, web_domCollections_iterator_js, React, ramda, core, _extends, _objectWithoutProperties, _toConsumableArray, _asyncToGenerator, _regeneratorRuntime, es_array_concat_js, es_array_find_js, es_array_includes_js, es_array_isArray_js, es_array_reduce_js, es_array_sort_js, es_array_splice_js, es_function_name_js, es_object_fromEntries_js, es_regexp_exec_js, es_string_replace_js, _typeof) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
  var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
  var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
  var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
  var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
  var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
  var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
  var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
  var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
  var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
  var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
  var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
  var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);

  var CubeContext = /*#__PURE__*/React.createContext(null);

  function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _callSuper$1(t, o, e) { return o = _getPrototypeOf__default['default'](o), _possibleConstructorReturn__default['default'](t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf__default['default'](t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
  var QueryRenderer = /*#__PURE__*/function (_React$Component) {
    function QueryRenderer(props) {
      var _this;
      _classCallCheck__default['default'](this, QueryRenderer);
      _this = _callSuper$1(this, QueryRenderer, [props]);
      _this.state = {};
      _this.mutexObj = {};
      return _this;
    }
    _inherits__default['default'](QueryRenderer, _React$Component);
    return _createClass__default['default'](QueryRenderer, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props = this.props,
          query = _this$props.query,
          queries = _this$props.queries;
        if (query) {
          this.load(query);
        }
        if (queries) {
          this.loadQueries(queries);
        }
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var _this$props2 = this.props,
          query = _this$props2.query,
          queries = _this$props2.queries,
          render = _this$props2.render,
          cubeApi = _this$props2.cubeApi,
          loadSql = _this$props2.loadSql,
          updateOnlyOnStateChange = _this$props2.updateOnlyOnStateChange;
        if (!updateOnlyOnStateChange) {
          return true;
        }
        return !ramda.equals(nextProps.query, query) || !ramda.equals(nextProps.queries, queries) || (nextProps.render == null || render == null) && nextProps.render !== render || nextProps.cubeApi !== cubeApi || nextProps.loadSql !== loadSql || !ramda.equals(nextState, this.state) || nextProps.updateOnlyOnStateChange !== updateOnlyOnStateChange;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props3 = this.props,
          query = _this$props3.query,
          queries = _this$props3.queries;
        if (!ramda.equals(prevProps.query, query)) {
          this.load(query);
        }
        if (!ramda.equals(prevProps.queries, queries)) {
          this.loadQueries(queries);
        }
      }
    }, {
      key: "cubeApi",
      value: function cubeApi() {
        // eslint-disable-next-line react/destructuring-assignment
        return this.props.cubeApi || this.context && this.context.cubeApi;
      }
    }, {
      key: "load",
      value: function load(query) {
        var _this2 = this;
        var resetResultSetOnChange = this.props.resetResultSetOnChange;
        this.setState(_objectSpread$6({
          isLoading: true,
          error: null,
          sqlQuery: null
        }, resetResultSetOnChange ? {
          resultSet: null
        } : {}));
        var loadSql = this.props.loadSql;
        var cubeApi = this.cubeApi();
        if (query && core.isQueryPresent(query)) {
          if (loadSql === 'only') {
            cubeApi.sql(query, {
              mutexObj: this.mutexObj,
              mutexKey: 'sql'
            }).then(function (sqlQuery) {
              return _this2.setState({
                sqlQuery: sqlQuery,
                error: null,
                isLoading: false
              });
            })["catch"](function (error) {
              return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {
                resultSet: null
              } : {}), {}, {
                error: error,
                isLoading: false
              }));
            });
          } else if (loadSql) {
            Promise.all([cubeApi.sql(query, {
              mutexObj: this.mutexObj,
              mutexKey: 'sql'
            }), cubeApi.load(query, {
              mutexObj: this.mutexObj,
              mutexKey: 'query'
            })]).then(function (_ref) {
              var _ref2 = _slicedToArray__default['default'](_ref, 2),
                sqlQuery = _ref2[0],
                resultSet = _ref2[1];
              return _this2.setState({
                sqlQuery: sqlQuery,
                resultSet: resultSet,
                error: null,
                isLoading: false
              });
            })["catch"](function (error) {
              return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {
                resultSet: null
              } : {}), {}, {
                error: error,
                isLoading: false
              }));
            });
          } else {
            cubeApi.load(query, {
              mutexObj: this.mutexObj,
              mutexKey: 'query'
            }).then(function (resultSet) {
              return _this2.setState({
                resultSet: resultSet,
                error: null,
                isLoading: false
              });
            })["catch"](function (error) {
              return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {
                resultSet: null
              } : {}), {}, {
                error: error,
                isLoading: false
              }));
            });
          }
        }
      }
    }, {
      key: "loadQueries",
      value: function loadQueries(queries) {
        var _this3 = this;
        var cubeApi = this.cubeApi();
        var resetResultSetOnChange = this.props.resetResultSetOnChange;
        this.setState(_objectSpread$6(_objectSpread$6({
          isLoading: true
        }, resetResultSetOnChange ? {
          resultSet: null
        } : {}), {}, {
          error: null
        }));
        var resultPromises = Promise.all(ramda.toPairs(queries).map(function (_ref3) {
          var _ref4 = _slicedToArray__default['default'](_ref3, 2),
            name = _ref4[0],
            query = _ref4[1];
          return cubeApi.load(query, {
            mutexObj: _this3.mutexObj,
            mutexKey: name
          }).then(function (r) {
            return [name, r];
          });
        }));
        resultPromises.then(function (resultSet) {
          return _this3.setState({
            resultSet: ramda.fromPairs(resultSet),
            error: null,
            isLoading: false
          });
        })["catch"](function (error) {
          return _this3.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {
            resultSet: null
          } : {}), {}, {
            error: error,
            isLoading: false
          }));
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _error$response;
        var _this$state = this.state,
          error = _this$state.error,
          queries = _this$state.queries,
          resultSet = _this$state.resultSet,
          isLoading = _this$state.isLoading,
          sqlQuery = _this$state.sqlQuery;
        var render = this.props.render;
        var loadState = {
          error: error ? new Error(((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.plainError) || error.message || error.toString()) : null,
          resultSet: queries ? resultSet || {} : resultSet,
          loadingState: {
            isLoading: isLoading
          },
          sqlQuery: sqlQuery
        };
        if (render) {
          return render(loadState);
        }
        return null;
      }
    }], [{
      key: "isQueryPresent",
      value:
      // @deprecated use `isQueryPresent` from `@cubejs-client/core`
      function isQueryPresent(query) {
        return core.isQueryPresent(query);
      }
    }]);
  }(React__default['default'].Component);
  _defineProperty__default['default'](QueryRenderer, "contextType", CubeContext);
  _defineProperty__default['default'](QueryRenderer, "defaultProps", {
    cubeApi: null,
    query: null,
    render: null,
    queries: null,
    loadSql: null,
    updateOnlyOnStateChange: false,
    resetResultSetOnChange: true
  });

  var _excluded$1 = ["query"];
  function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  var QueryRendererWithTotals = function QueryRendererWithTotals(_ref) {
    var query = _ref.query,
      restProps = _objectWithoutProperties__default['default'](_ref, _excluded$1);
    return /*#__PURE__*/React__default['default'].createElement(QueryRenderer, _extends__default['default']({
      queries: {
        totals: _objectSpread$5(_objectSpread$5({}, query), {}, {
          dimensions: [],
          timeDimensions: query.timeDimensions ? query.timeDimensions.map(function (td) {
            return _objectSpread$5(_objectSpread$5({}, td), {}, {
              granularity: null
            });
          }) : undefined
        }),
        main: query
      }
    }, restProps));
  };

  function removeEmpty(obj) {
    if (Array.isArray(obj) || _typeof__default['default'](obj) !== 'object') {
      return obj;
    }
    return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
      var _ref2 = _slicedToArray__default['default'](_ref, 2),
        v = _ref2[1];
      return v != null;
    }).map(function (_ref3) {
      var _ref4 = _slicedToArray__default['default'](_ref3, 2),
        k = _ref4[0],
        v = _ref4[1];
      if (Array.isArray(v)) {
        return [k, v.map(removeEmpty)];
      }
      return [k, _typeof__default['default'](v) === 'object' ? removeEmpty(v) : v];
    }));
  }

  function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _callSuper(t, o, e) { return o = _getPrototypeOf__default['default'](o), _possibleConstructorReturn__default['default'](t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf__default['default'](t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var granularities = [{
    name: undefined,
    title: 'w/o grouping'
  }, {
    name: 'second',
    title: 'Second'
  }, {
    name: 'minute',
    title: 'Minute'
  }, {
    name: 'hour',
    title: 'Hour'
  }, {
    name: 'day',
    title: 'Day'
  }, {
    name: 'week',
    title: 'Week'
  }, {
    name: 'month',
    title: 'Month'
  }, {
    name: 'quarter',
    title: 'Quarter'
  }, {
    name: 'year',
    title: 'Year'
  }];
  var QueryBuilder = /*#__PURE__*/function (_React$Component) {
    function QueryBuilder(props) {
      var _this;
      _classCallCheck__default['default'](this, QueryBuilder);
      _this = _callSuper(this, QueryBuilder, [props]);
      _defineProperty__default['default'](_this, "fetchMeta", /*#__PURE__*/_asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var meta, metaError, richMetaError, metaErrorStack, _error$response, _error$response2;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (_this.cubeApi()) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              metaError = null;
              richMetaError = null;
              metaErrorStack = null;
              _context.prev = 5;
              _this.setState({
                isFetchingMeta: true
              });
              _context.next = 9;
              return _this.cubeApi().meta();
            case 9:
              meta = _context.sent;
              _context.next = 17;
              break;
            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](5);
              metaError = ((_error$response = _context.t0.response) === null || _error$response === void 0 ? void 0 : _error$response.plainError) || _context.t0;
              richMetaError = _context.t0;
              metaErrorStack = ((_error$response2 = _context.t0.response) === null || _error$response2 === void 0 || (_error$response2 = _error$response2.stack) === null || _error$response2 === void 0 ? void 0 : _error$response2.replace(_context.t0.message || '', '')) || '';
            case 17:
              _this.setState({
                meta: meta,
                metaError: metaError ? new Error(metaError.message || metaError.toString()) : null,
                richMetaError: richMetaError,
                metaErrorStack: metaErrorStack,
                isFetchingMeta: false
              }, function () {
                // Run update query to force viz state update
                // This will catch any new missing members, and also validate the query against the new meta
                _this.updateQuery({});
              });
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[5, 12]]);
      })));
      _this.state = _objectSpread$4(_objectSpread$4({
        query: props.defaultQuery || props.query,
        chartType: props.defaultChartType,
        validatedQuery: props.query,
        // deprecated, validatedQuery should not be set until after dry-run for safety
        missingMembers: [],
        // todo: rename to `isMetaReady`
        isFetchingMeta: true,
        dryRunResponse: null
      }, props.vizState), props.initialVizState);
      _this.mutexObj = {};
      _this.orderMembersOrderKeys = [];
      return _this;
    }
    _inherits__default['default'](QueryBuilder, _React$Component);
    return _createClass__default['default'](QueryBuilder, [{
      key: "componentDidMount",
      value: function () {
        var _componentDidMount = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
          return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                this.prevContext = this.context;
                _context2.next = 3;
                return this.fetchMeta();
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function componentDidMount() {
          return _componentDidMount.apply(this, arguments);
        }
        return componentDidMount;
      }()
    }, {
      key: "componentDidUpdate",
      value: function () {
        var _componentDidUpdate = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(prevProps) {
          var _this$prevContext,
            _this$context,
            _this2 = this;
          var _this$props, schemaVersion, onSchemaChange, meta, newMeta;
          return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _this$props = this.props, schemaVersion = _this$props.schemaVersion, onSchemaChange = _this$props.onSchemaChange;
                meta = this.state.meta;
                if (!(((_this$prevContext = this.prevContext) === null || _this$prevContext === void 0 ? void 0 : _this$prevContext.cubeApi) !== ((_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.cubeApi))) {
                  _context4.next = 6;
                  break;
                }
                this.prevContext = this.context;
                _context4.next = 6;
                return this.fetchMeta();
              case 6:
                if (!(prevProps.schemaVersion !== schemaVersion)) {
                  _context4.next = 17;
                  break;
                }
                _context4.prev = 7;
                _context4.next = 10;
                return this.cubeApi().meta();
              case 10:
                newMeta = _context4.sent;
                if (!ramda.equals(newMeta, meta) && typeof onSchemaChange === 'function') {
                  onSchemaChange({
                    schemaVersion: schemaVersion,
                    refresh: function () {
                      var _refresh = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
                        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
                          while (1) switch (_context3.prev = _context3.next) {
                            case 0:
                              _context3.next = 2;
                              return _this2.fetchMeta();
                            case 2:
                            case "end":
                              return _context3.stop();
                          }
                        }, _callee3);
                      }));
                      function refresh() {
                        return _refresh.apply(this, arguments);
                      }
                      return refresh;
                    }()
                  });
                }
                _context4.next = 17;
                break;
              case 14:
                _context4.prev = 14;
                _context4.t0 = _context4["catch"](7);
                // eslint-disable-next-line
                this.setState({
                  metaError: _context4.t0
                });
              case 17:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this, [[7, 14]]);
        }));
        function componentDidUpdate(_x) {
          return _componentDidUpdate.apply(this, arguments);
        }
        return componentDidUpdate;
      }()
    }, {
      key: "cubeApi",
      value: function cubeApi() {
        var cubeApi = this.props.cubeApi;
        // eslint-disable-next-line react/destructuring-assignment
        return cubeApi || this.context && this.context.cubeApi;
      }
    }, {
      key: "getMissingMembers",
      value: function getMissingMembers(query, meta) {
        if (!meta) {
          return [];
        }
        return core.getQueryMembers(query).map(function (member) {
          var resolvedMember = meta.resolveMember(member, ['measures', 'dimensions', 'segments']);
          if (resolvedMember.error) {
            return member;
          }
          return false;
        }).filter(Boolean);
      }
    }, {
      key: "isQueryPresent",
      value: function isQueryPresent() {
        var query = this.state.query;
        return QueryRenderer.isQueryPresent(query);
      }
    }, {
      key: "prepareRenderProps",
      value: function prepareRenderProps(queryRendererProps) {
        var _this3 = this;
        var getName = function getName(member) {
          return member.name;
        };
        var toTimeDimension = function toTimeDimension(member) {
          var rangeSelection = member.compareDateRange ? {
            compareDateRange: member.compareDateRange
          } : {
            dateRange: member.dateRange
          };
          return removeEmpty(_objectSpread$4({
            dimension: member.dimension.name,
            granularity: member.granularity
          }, rangeSelection));
        };
        var toFilter = function toFilter(member) {
          var _member$member, _member$dimension;
          return _objectSpread$4({
            member: ((_member$member = member.member) === null || _member$member === void 0 ? void 0 : _member$member.name) || ((_member$dimension = member.dimension) === null || _member$dimension === void 0 ? void 0 : _member$dimension.name),
            operator: member.operator
          }, ['set', 'notSet'].includes(member.operator) ? {} : {
            values: member.values
          });
        };
        var updateMethods = function updateMethods(memberType) {
          var toQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getName;
          return {
            add: function add(member) {
              var query = _this3.state.query;
              _this3.updateQuery(_defineProperty__default['default']({}, memberType, (query[memberType] || []).concat(toQuery(member))));
            },
            remove: function remove(member) {
              var query = _this3.state.query;
              return _this3.updateQuery(_defineProperty__default['default']({}, memberType, (query[memberType] || []).filter(function (_, index) {
                return index !== member.index;
              })));
            },
            update: function update(member, updateWith) {
              var query = _this3.state.query;
              var members = (query[memberType] || []).concat([]);
              members.splice(member.index, 1, toQuery(updateWith));
              return _this3.updateQuery(_defineProperty__default['default']({}, memberType, members));
            }
          };
        };
        var _this$state = this.state,
          meta = _this$state.meta,
          metaError = _this$state.metaError,
          richMetaError = _this$state.richMetaError,
          query = _this$state.query,
          queryError = _this$state.queryError,
          chartType = _this$state.chartType,
          pivotConfig = _this$state.pivotConfig,
          validatedQuery = _this$state.validatedQuery,
          missingMembers = _this$state.missingMembers,
          isFetchingMeta = _this$state.isFetchingMeta,
          dryRunResponse = _this$state.dryRunResponse,
          metaErrorStack = _this$state.metaErrorStack;
        var flatFilters = ramda.uniqBy(function (filter) {
          return "".concat(ramda.prop('member', filter)).concat(ramda.prop('operator', filter));
        }, core.flattenFilters(meta && query.filters || []).map(function (filter) {
          return _objectSpread$4(_objectSpread$4({}, filter), {}, {
            member: filter.member || filter.dimension
          });
        }));
        var filters = flatFilters.map(function (m, i) {
          return _objectSpread$4(_objectSpread$4({}, m), {}, {
            dimension: meta.resolveMember(m.member || m.dimension, ['dimensions', 'measures']),
            operators: meta.filterOperatorsForMember(m.member || m.dimension, ['dimensions', 'measures']),
            index: i
          });
        });
        var measures = QueryBuilder.resolveMember('measures', this.state);
        var dimensions = QueryBuilder.resolveMember('dimensions', this.state);
        var timeDimensions = QueryBuilder.resolveMember('timeDimensions', this.state);
        var segments = (meta && query.segments || []).map(function (m, i) {
          return _objectSpread$4({
            index: i
          }, meta.resolveMember(m, 'segments'));
        });
        var availableMeasures = [];
        var availableDimensions = [];
        var availableSegments = [];
        var availableFilterMembers = [];
        var availableMembers = (meta === null || meta === void 0 ? void 0 : meta.membersGroupedByCube()) || {
          measures: [],
          dimensions: [],
          segments: [],
          timeDimensions: []
        };
        if (meta) {
          availableMeasures = meta.membersForQuery(query, 'measures');
          availableDimensions = meta.membersForQuery(query, 'dimensions');
          availableSegments = meta.membersForQuery(query, 'segments');
          var indexedMeasures = ramda.indexBy(ramda.prop('cubeName'), availableMembers.measures);
          var indexedDimensions = ramda.indexBy(ramda.prop('cubeName'), availableMembers.dimensions);
          var cubeNames = ramda.uniq([].concat(_toConsumableArray__default['default'](Object.keys(indexedMeasures)), _toConsumableArray__default['default'](Object.keys(indexedDimensions)))).sort();
          availableFilterMembers = cubeNames.map(function (name) {
            var _indexedMeasures$name, _indexedDimensions$na;
            var cube = indexedMeasures[name] || indexedDimensions[name];
            return _objectSpread$4(_objectSpread$4({}, cube), {}, {
              members: [].concat(_toConsumableArray__default['default']((_indexedMeasures$name = indexedMeasures[name]) === null || _indexedMeasures$name === void 0 ? void 0 : _indexedMeasures$name.members), _toConsumableArray__default['default']((_indexedDimensions$na = indexedDimensions[name]) === null || _indexedDimensions$na === void 0 ? void 0 : _indexedDimensions$na.members)).sort(function (a, b) {
                return a.shortTitle > b.shortTitle ? 1 : -1;
              })
            });
          });
        }
        var activeOrder = Array.isArray(query.order) ? Object.fromEntries(query.order) : query.order;
        var members = [].concat(_toConsumableArray__default['default'](measures), _toConsumableArray__default['default'](dimensions), _toConsumableArray__default['default'](timeDimensions.map(function (_ref2) {
          var dimension = _ref2.dimension;
          return dimension;
        })));
        var orderMembers = ramda.uniqBy(ramda.prop('id'), _toConsumableArray__default['default'](members.map(function (_ref3) {
          var name = _ref3.name,
            title = _ref3.title;
          return {
            id: name,
            title: title,
            order: (activeOrder === null || activeOrder === void 0 ? void 0 : activeOrder[name]) || 'none'
          };
        })));
        if (this.orderMembersOrderKeys.length !== orderMembers.length) {
          this.orderMembersOrderKeys = orderMembers.map(function (_ref4) {
            var id = _ref4.id;
            return id;
          });
        }
        if (this.orderMembersOrderKeys.length) {
          // Preserve order until the members change or manually re-ordered
          // This is needed so that when an order member becomes active, it doesn't jump to the top of the list
          orderMembers = (this.orderMembersOrderKeys || []).map(function (id) {
            return orderMembers.find(function (member) {
              return member.id === id;
            });
          }).filter(Boolean);
        }
        return _objectSpread$4({
          meta: meta,
          metaError: metaError,
          richMetaError: richMetaError,
          metaErrorStack: metaErrorStack,
          query: query,
          error: queryError,
          // Match same name as QueryRenderer prop
          validatedQuery: validatedQuery,
          isQueryPresent: this.isQueryPresent(),
          chartType: chartType,
          measures: measures,
          dimensions: dimensions,
          timeDimensions: timeDimensions,
          segments: segments,
          filters: filters,
          orderMembers: orderMembers,
          availableMeasures: availableMeasures,
          availableDimensions: availableDimensions,
          availableTimeDimensions: availableDimensions.filter(function (m) {
            return m.type === 'time';
          }),
          availableSegments: availableSegments,
          availableMembers: availableMembers,
          availableFilterMembers: availableFilterMembers,
          updateQuery: function updateQuery(queryUpdate) {
            return _this3.updateQuery(queryUpdate);
          },
          updateMeasures: updateMethods('measures'),
          updateDimensions: updateMethods('dimensions'),
          updateSegments: updateMethods('segments'),
          updateTimeDimensions: updateMethods('timeDimensions', toTimeDimension),
          updateFilters: updateMethods('filters', toFilter),
          updateChartType: function updateChartType(newChartType) {
            return _this3.updateVizState({
              chartType: newChartType
            });
          },
          updateOrder: {
            set: function set(memberId) {
              var newOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asc';
              _this3.updateQuery({
                order: orderMembers.map(function (orderMember) {
                  return _objectSpread$4(_objectSpread$4({}, orderMember), {}, {
                    order: orderMember.id === memberId ? newOrder : orderMember.order
                  });
                }).reduce(function (acc, _ref5) {
                  var id = _ref5.id,
                    order = _ref5.order;
                  return order !== 'none' ? [].concat(_toConsumableArray__default['default'](acc), [[id, order]]) : acc;
                }, [])
              });
            },
            update: function update(order) {
              _this3.updateQuery({
                order: order
              });
            },
            reorder: function reorder(sourceIndex, destinationIndex) {
              if (sourceIndex == null || destinationIndex == null) {
                return;
              }
              var nextArray = core.moveItemInArray(orderMembers, sourceIndex, destinationIndex);
              _this3.orderMembersOrderKeys = nextArray.map(function (_ref6) {
                var id = _ref6.id;
                return id;
              });
              _this3.updateQuery({
                order: nextArray.reduce(function (acc, _ref7) {
                  var id = _ref7.id,
                    order = _ref7.order;
                  return order !== 'none' ? [].concat(_toConsumableArray__default['default'](acc), [[id, order]]) : acc;
                }, [])
              });
            }
          },
          pivotConfig: pivotConfig,
          updatePivotConfig: {
            moveItem: function moveItem(_ref8) {
              var sourceIndex = _ref8.sourceIndex,
                destinationIndex = _ref8.destinationIndex,
                sourceAxis = _ref8.sourceAxis,
                destinationAxis = _ref8.destinationAxis;
              _this3.updateVizState({
                pivotConfig: core.movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis)
              });
            },
            update: function update(config) {
              var limit = config.limit;
              _this3.updateVizState(_objectSpread$4({
                pivotConfig: _objectSpread$4(_objectSpread$4({}, pivotConfig), config)
              }, limit ? {
                query: _objectSpread$4(_objectSpread$4({}, query), {}, {
                  limit: limit
                })
              } : null));
            }
          },
          missingMembers: missingMembers,
          refresh: this.fetchMeta,
          isFetchingMeta: isFetchingMeta,
          dryRunResponse: dryRunResponse
        }, queryRendererProps);
      }
    }, {
      key: "updateQuery",
      value: function updateQuery(queryUpdate) {
        var query = this.state.query;
        this.updateVizState({
          query: core.removeEmptyQueryFields(_objectSpread$4(_objectSpread$4({}, query), queryUpdate))
        });
      }
    }, {
      key: "updateVizState",
      value: function () {
        var _updateVizState = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(state) {
          var _this4 = this;
          var _this$props2, setQuery, setVizState, _this$state2, stateQuery, statePivotConfig, chartType, meta, finalState, vizStateSent, handleVizStateChange, runSetters, shouldFetchDryRun, response, _error$response3;
          return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _this$props2 = this.props, setQuery = _this$props2.setQuery, setVizState = _this$props2.setVizState;
                _this$state2 = this.state, stateQuery = _this$state2.query, statePivotConfig = _this$state2.pivotConfig, chartType = _this$state2.chartType, meta = _this$state2.meta;
                finalState = this.applyStateChangeHeuristics(state);
                if (!finalState.query) {
                  finalState.query = _objectSpread$4({}, stateQuery);
                }
                vizStateSent = null;
                handleVizStateChange = function handleVizStateChange(currentState) {
                  var onVizStateChanged = _this4.props.onVizStateChanged;
                  if (onVizStateChanged) {
                    var newVizState = ramda.pick(['chartType', 'pivotConfig', 'query'], currentState);
                    // Don't run callbacks more than once unless the viz state has changed since last time
                    if (!vizStateSent || !ramda.equals(vizStateSent, newVizState)) {
                      onVizStateChanged(newVizState);
                      // use clone to make sure we don't save object references
                      vizStateSent = ramda.clone(newVizState);
                    }
                  }
                }; // deprecated, setters replaced by onVizStateChanged
                runSetters = function runSetters(currentState) {
                  if (setVizState) {
                    setVizState(ramda.pick(['chartType', 'pivotConfig', 'query'], currentState));
                  }
                  if (currentState.query && setQuery) {
                    setQuery(currentState.query);
                  }
                };
                if (finalState.shouldApplyHeuristicOrder) {
                  finalState.query.order = core.defaultOrder(finalState.query);
                }
                finalState.pivotConfig = core.ResultSet.getNormalizedPivotConfig(finalState.query, finalState.pivotConfig !== undefined ? finalState.pivotConfig : statePivotConfig);
                finalState.missingMembers = this.getMissingMembers(finalState.query, meta);
                finalState.chartType = finalState.chartType || state.chartType || chartType;

                // deprecated
                runSetters(_objectSpread$4(_objectSpread$4({}, state), {}, {
                  query: finalState.query
                }));

                // Update optimistically so that UI does not stutter
                this.setState(_objectSpread$4(_objectSpread$4({}, finalState), {}, {
                  queryError: null
                }));
                handleVizStateChange(finalState);
                shouldFetchDryRun = !ramda.equals(ramda.pick(['measures', 'dimensions', 'timeDimensions'], stateQuery), ramda.pick(['measures', 'dimensions', 'timeDimensions'], finalState.query));
                if (!(shouldFetchDryRun && core.isQueryPresent(finalState.query) && finalState.missingMembers.length === 0)) {
                  _context5.next = 30;
                  break;
                }
                _context5.prev = 16;
                _context5.next = 19;
                return this.cubeApi().dryRun(finalState.query, {
                  mutexObj: this.mutexObj
                });
              case 19:
                response = _context5.sent;
                if (finalState.shouldApplyHeuristicOrder) {
                  finalState.query.order = (response.queryOrder || []).reduce(function (memo, current) {
                    return _objectSpread$4(_objectSpread$4({}, memo), current);
                  }, {});
                }
                finalState.pivotConfig = core.ResultSet.getNormalizedPivotConfig(response.pivotQuery, finalState.pivotConfig);
                finalState.validatedQuery = this.validatedQuery(finalState);
                finalState.dryRunResponse = response;

                // deprecated
                if (core.isQueryPresent(stateQuery)) {
                  runSetters(_objectSpread$4(_objectSpread$4({}, this.state), finalState));
                }
                _context5.next = 30;
                break;
              case 27:
                _context5.prev = 27;
                _context5.t0 = _context5["catch"](16);
                this.setState({
                  queryError: new Error(((_error$response3 = _context5.t0.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.plainError) || _context5.t0.message),
                  richQueryError: new Error(_context5.t0.message || _context5.t0.toString())
                });
              case 30:
                this.setState(finalState, function () {
                  return handleVizStateChange(_this4.state);
                });
              case 31:
              case "end":
                return _context5.stop();
            }
          }, _callee5, this, [[16, 27]]);
        }));
        function updateVizState(_x2) {
          return _updateVizState.apply(this, arguments);
        }
        return updateVizState;
      }()
    }, {
      key: "validatedQuery",
      value: function validatedQuery(state) {
        var _ref9 = state || this.state,
          query = _ref9.query;
        return core.validateQuery(query);
      }
    }, {
      key: "defaultHeuristics",
      value: function defaultHeuristics(newState) {
        var _this$state3 = this.state,
          query = _this$state3.query,
          sessionGranularity = _this$state3.sessionGranularity,
          meta = _this$state3.meta;
        return core.defaultHeuristics(newState, query, {
          meta: meta,
          sessionGranularity: sessionGranularity || 'day'
        });
      }
    }, {
      key: "applyStateChangeHeuristics",
      value: function applyStateChangeHeuristics(newState) {
        var _this$props3 = this.props,
          stateChangeHeuristics = _this$props3.stateChangeHeuristics,
          disableHeuristics = _this$props3.disableHeuristics;
        if (disableHeuristics) {
          return newState;
        }
        return stateChangeHeuristics && stateChangeHeuristics(this.state, newState) || this.defaultHeuristics(newState);
      }
    }, {
      key: "render",
      value: function _render() {
        var _this5 = this;
        var query = this.state.query;
        var _this$props4 = this.props,
          cubeApi = _this$props4.cubeApi,
          _render = _this$props4.render,
          wrapWithQueryRenderer = _this$props4.wrapWithQueryRenderer;
        if (wrapWithQueryRenderer) {
          return /*#__PURE__*/React__default['default'].createElement(QueryRenderer, {
            query: query,
            cubeApi: cubeApi,
            resetResultSetOnChange: false,
            render: function render(queryRendererProps) {
              if (_render) {
                return _render(_this5.prepareRenderProps(queryRendererProps));
              }
              return null;
            }
          });
        } else {
          if (_render) {
            return _render(this.prepareRenderProps());
          }
          return null;
        }
      }
    }], [{
      key: "getDerivedStateFromProps",
      value:
      // This is an anti-pattern, only kept for backward compatibility
      // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state
      function getDerivedStateFromProps(props, state) {
        if (props.query || props.vizState) {
          var nextState = _objectSpread$4(_objectSpread$4({}, state), props.vizState || {});
          if (Array.isArray(props.query)) {
            throw new Error('Array of queries is not supported.');
          }
          return _objectSpread$4(_objectSpread$4({}, nextState), {}, {
            query: _objectSpread$4(_objectSpread$4({}, nextState.query), props.query || {})
          });
        }
        return null;
      }
    }, {
      key: "resolveMember",
      value: function resolveMember(type, _ref10) {
        var meta = _ref10.meta,
          query = _ref10.query;
        if (!meta) {
          return [];
        }
        if (Array.isArray(query)) {
          return query.reduce(function (memo, currentQuery) {
            return memo.concat(QueryBuilder.resolveMember(type, {
              meta: meta,
              query: currentQuery
            }));
          }, []);
        }
        if (type === 'timeDimensions') {
          return (query.timeDimensions || []).map(function (m, index) {
            return _objectSpread$4(_objectSpread$4({}, m), {}, {
              dimension: _objectSpread$4(_objectSpread$4({}, meta.resolveMember(m.dimension, 'dimensions')), {}, {
                granularities: granularities
              }),
              index: index
            });
          });
        }
        return (query[type] || []).map(function (m, index) {
          return _objectSpread$4({
            index: index
          }, meta.resolveMember(m, type));
        });
      }
    }]);
  }(React__default['default'].Component);
  _defineProperty__default['default'](QueryBuilder, "contextType", CubeContext);
  _defineProperty__default['default'](QueryBuilder, "defaultProps", {
    cubeApi: null,
    stateChangeHeuristics: null,
    disableHeuristics: false,
    render: null,
    wrapWithQueryRenderer: true,
    defaultChartType: 'line',
    defaultQuery: {},
    initialVizState: null,
    onVizStateChanged: null,
    // deprecated
    query: null,
    setQuery: null,
    vizState: null,
    setVizState: null
  });

  function CubeProvider(_ref) {
    var cubeApi = _ref.cubeApi,
      children = _ref.children,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? {} : _ref$options;
    return /*#__PURE__*/React__default['default'].createElement(CubeContext.Provider, {
      value: {
        cubeApi: cubeApi,
        options: options
      }
    }, children);
  }

  function useDeepCompareMemoize(value) {
    var ref = React.useRef([]);
    if (!ramda.equals(value, ref.current)) {
      ref.current = value;
    }
    return ref.current;
  }

  function useIsMounted() {
    var isMounted = React.useRef(false);
    React.useEffect(function () {
      isMounted.current = true;
      return function () {
        isMounted.current = false;
      };
    }, []);
    return function () {
      return isMounted.current;
    };
  }

  function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function useCubeFetch(method) {
    var _options$query;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var isMounted = useIsMounted();
    var context = React.useContext(CubeContext);
    var mutexRef = React.useRef({});
    var _useState = React.useState({
        isLoading: false,
        response: null
      }),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      response = _useState2[0],
      setResponse = _useState2[1];
    var _useState3 = React.useState(null),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];
    var _options$skip = options.skip,
      skip = _options$skip === void 0 ? false : _options$skip;
    function load() {
      return _load.apply(this, arguments);
    }
    function _load() {
      _load = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var loadOptions,
          ignoreSkip,
          cubeApi,
          query,
          queryCondition,
          coreOptions,
          args,
          _response,
          _args = arguments;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              loadOptions = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              ignoreSkip = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
              cubeApi = options.cubeApi || (context === null || context === void 0 ? void 0 : context.cubeApi);
              query = loadOptions.query || options.query;
              queryCondition = method === 'meta' ? true : query && core.isQueryPresent(query);
              if (!(cubeApi && (ignoreSkip || !skip) && queryCondition)) {
                _context.next = 20;
                break;
              }
              setError(null);
              setResponse({
                isLoading: true,
                response: null
              });
              coreOptions = {
                mutexObj: mutexRef.current,
                mutexKey: method
              };
              args = method === 'meta' ? [coreOptions] : [query, coreOptions];
              _context.prev = 10;
              _context.next = 13;
              return cubeApi[method].apply(cubeApi, args);
            case 13:
              _response = _context.sent;
              if (isMounted()) {
                setResponse({
                  response: _response,
                  isLoading: false
                });
              }
              _context.next = 20;
              break;
            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](10);
              if (isMounted()) {
                setError(_context.t0);
                setResponse({
                  isLoading: false,
                  response: null
                });
              }
            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[10, 17]]);
      }));
      return _load.apply(this, arguments);
    }
    React.useEffect(function () {
      load();
    }, useDeepCompareMemoize([Object.keys(((_options$query = options.query) === null || _options$query === void 0 ? void 0 : _options$query.order) || {}), options, context]));
    return _objectSpread$3(_objectSpread$3({}, response), {}, {
      error: error,
      refetch: function refetch(options) {
        return load(options, true);
      }
    });
  }

  function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function useCubeSql(query) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return useCubeFetch('sql', _objectSpread$2(_objectSpread$2({}, options), {}, {
      query: query
    }));
  }

  function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function useDryRun(query) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return useCubeFetch('dryRun', _objectSpread$1(_objectSpread$1({}, options), {}, {
      query: query
    }));
  }

  var _excluded = ["refetch"];
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default['default'](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function useLazyDryRun(query) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _useCubeFetch = useCubeFetch('dryRun', _objectSpread(_objectSpread({}, options), {}, {
        query: query,
        skip: true
      })),
      refetch = _useCubeFetch.refetch,
      result = _objectWithoutProperties__default['default'](_useCubeFetch, _excluded);
    return [refetch, result];
  }

  function useCubeQuery(query) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var mutexRef = React.useRef({});
    var isMounted = useIsMounted();
    var _useState = React.useState(null),
      _useState2 = _slicedToArray__default['default'](_useState, 2),
      currentQuery = _useState2[0],
      setCurrentQuery = _useState2[1];
    var _useState3 = React.useState(!options.skip),
      _useState4 = _slicedToArray__default['default'](_useState3, 2),
      isLoading = _useState4[0],
      setLoading = _useState4[1];
    var _useState5 = React.useState(null),
      _useState6 = _slicedToArray__default['default'](_useState5, 2),
      resultSet = _useState6[0],
      setResultSet = _useState6[1];
    var _useState7 = React.useState(null),
      _useState8 = _slicedToArray__default['default'](_useState7, 2),
      progress = _useState8[0],
      setProgress = _useState8[1];
    var _useState9 = React.useState(null),
      _useState10 = _slicedToArray__default['default'](_useState9, 2),
      error = _useState10[0],
      setError = _useState10[1];
    var context = React.useContext(CubeContext);
    var subscribeRequest = null;
    var progressCallback = function progressCallback(_ref) {
      var progressResponse = _ref.progressResponse;
      return setProgress(progressResponse);
    };
    function fetch() {
      return _fetch.apply(this, arguments);
    }
    function _fetch() {
      _fetch = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        var resetResultSetOnChange, cubeApi, _context$options, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              resetResultSetOnChange = options.resetResultSetOnChange;
              cubeApi = options.cubeApi || (context === null || context === void 0 ? void 0 : context.cubeApi);
              if (cubeApi) {
                _context2.next = 4;
                break;
              }
              throw new Error('Cube API client is not provided');
            case 4:
              if (resetResultSetOnChange) {
                setResultSet(null);
              }
              setError(null);
              setLoading(true);
              _context2.prev = 7;
              _context2.next = 10;
              return cubeApi.load(query, {
                mutexObj: mutexRef.current,
                mutexKey: 'query',
                progressCallback: progressCallback,
                castNumerics: Boolean(typeof options.castNumerics === 'boolean' ? options.castNumerics : context === null || context === void 0 || (_context$options = context.options) === null || _context$options === void 0 ? void 0 : _context$options.castNumerics)
              });
            case 10:
              response = _context2.sent;
              if (isMounted()) {
                setResultSet(response);
                setProgress(null);
              }
              _context2.next = 17;
              break;
            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](7);
              if (isMounted()) {
                setError(_context2.t0);
                setResultSet(null);
                setProgress(null);
              }
            case 17:
              if (isMounted()) {
                setLoading(false);
              }
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[7, 14]]);
      }));
      return _fetch.apply(this, arguments);
    }
    React.useEffect(function () {
      var _options$skip = options.skip,
        skip = _options$skip === void 0 ? false : _options$skip,
        resetResultSetOnChange = options.resetResultSetOnChange;
      var cubeApi = options.cubeApi || (context === null || context === void 0 ? void 0 : context.cubeApi);
      if (!cubeApi) {
        throw new Error('Cube API client is not provided');
      }
      function loadQuery() {
        return _loadQuery.apply(this, arguments);
      }
      function _loadQuery() {
        _loadQuery = _asyncToGenerator__default['default'](/*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
          return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(!skip && core.isQueryPresent(query))) {
                  _context.next = 20;
                  break;
                }
                if (!core.areQueriesEqual(currentQuery, query)) {
                  if (resetResultSetOnChange == null || resetResultSetOnChange) {
                    setResultSet(null);
                  }
                  setCurrentQuery(query);
                }
                setError(null);
                setLoading(true);
                _context.prev = 4;
                if (!subscribeRequest) {
                  _context.next = 9;
                  break;
                }
                _context.next = 8;
                return subscribeRequest.unsubscribe();
              case 8:
                subscribeRequest = null;
              case 9:
                if (!options.subscribe) {
                  _context.next = 13;
                  break;
                }
                subscribeRequest = cubeApi.subscribe(query, {
                  mutexObj: mutexRef.current,
                  mutexKey: 'query',
                  progressCallback: progressCallback
                }, function (e, result) {
                  if (isMounted()) {
                    if (e) {
                      setError(e);
                    } else {
                      setResultSet(result);
                    }
                    setLoading(false);
                    setProgress(null);
                  }
                });
                _context.next = 15;
                break;
              case 13:
                _context.next = 15;
                return fetch();
              case 15:
                _context.next = 20;
                break;
              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](4);
                if (isMounted()) {
                  setError(_context.t0);
                  setResultSet(null);
                  setLoading(false);
                  setProgress(null);
                }
              case 20:
              case "end":
                return _context.stop();
            }
          }, _callee, null, [[4, 17]]);
        }));
        return _loadQuery.apply(this, arguments);
      }
      loadQuery();
      return function () {
        if (subscribeRequest) {
          subscribeRequest.unsubscribe();
          subscribeRequest = null;
        }
      };
    }, useDeepCompareMemoize([query, Object.keys(query && query.order || {}), options, context]));
    return {
      isLoading: isLoading,
      resultSet: resultSet,
      error: error,
      progress: progress,
      previousQuery: currentQuery,
      refetch: fetch
    };
  }

  function useCubeMeta() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return useCubeFetch('meta', options);
  }

  exports.CubeContext = CubeContext;
  exports.CubeProvider = CubeProvider;
  exports.QueryBuilder = QueryBuilder;
  exports.QueryRenderer = QueryRenderer;
  exports.QueryRendererWithTotals = QueryRendererWithTotals;
  exports.useCubeMeta = useCubeMeta;
  exports.useCubeQuery = useCubeQuery;
  exports.useCubeSql = useCubeSql;
  exports.useDryRun = useDryRun;
  exports.useLazyDryRun = useLazyDryRun;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cubejs-client-react.umd.js.map
